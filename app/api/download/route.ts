import { NextRequest } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import JSZip from 'jszip'

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url)
    const pathname = url.pathname
    
    // Extract filename from the path (e.g., /api/download/build-123.apk -> build-123.apk)
    const filename = pathname.split('/').pop()
    
    // Check if it's a build file request
    if (filename && filename.startsWith('build-') && filename.endsWith('.apk')) {
      // Generate a mock APK file for demonstration
      const mockApkContent = `This is a mock APK file for ${filename}

In a real implementation, this would be:
1. A real APK file generated by EAS Build
2. Served from EAS Build servers  
3. Or from your own build artifact storage

Build completed on: ${new Date().toLocaleString()}

To get real APK files, you would:
- Set up EAS Build with expo build:android
- Store build artifacts in cloud storage
- Serve them through this endpoint
      `
      
      return new Response(mockApkContent, {
        headers: {
          'Content-Type': 'application/vnd.android.package-archive',
          'Content-Disposition': `attachment; filename="${filename}"`,
        }
      })
    }
    
    return new Response('File not found', { status: 404 })
  } catch (error) {
    console.error('Download GET error:', error)
    return new Response('Download failed', { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const { userId } = await auth()
    if (!userId) {
      return new Response(
        JSON.stringify({ error: 'Authentication required' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    const { files, projectName } = await request.json()

    if (!files || typeof files !== 'object') {
      return new Response(
        JSON.stringify({ error: 'Files data is required' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Create a new JSZip instance
    const zip = new JSZip()

    // Add files to the zip
    Object.entries(files).forEach(([path, content]) => {
      zip.file(path, content as string)
    })

    // Add README with instructions
    const readme = `# ${projectName || 'Generated Expo App'}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Start the development server:
   \`\`\`bash
   npx expo start
   \`\`\`

3. Use Expo Go app on your phone to scan the QR code, or:
   - Press 'a' for Android emulator
   - Press 'i' for iOS simulator
   - Press 'w' for web

## Features

This app was generated using Prism AI App Builder.

## Next Steps

- Customize the UI and add your own features
- Add more screens and navigation
- Integrate with APIs and services
- Deploy to app stores using Expo EAS Build

Generated on: ${new Date().toLocaleString()}
`
    
    zip.file('README.md', readme)

    // Generate the zip file
    const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' })

    // Return the zip file
    return new Response(zipBuffer, {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${projectName || 'expo-app'}.zip"`,
      }
    })

  } catch (error) {
    console.error('Download API error:', error)
    const errorMessage = error instanceof Error ? error.message : 'Download failed'
    
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
} 